<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Графік можливих відключень — Шаблон</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --panel: #ffffff;
      --text: #0e1624;
      --muted: #6b7785;
      --hash: rgba(14, 22, 36, 0.08);
      --grid: #e2e8f0;
      --grid-strong: #cbd5e1;
      --accent: #0b6bcb;
      --head: #f1f5f9;
      --maybe-bg: rgba(15, 23, 42, 0.12);
      /* Warm yellow accents for highlighting today's row in weekly matrix */
      --today-border: #f2b200; /* warm amber/yellow for borders */
      --today-bg: #fff4cc;    /* light warm yellow background for day header */
    }

    /* Optional dark theme override (URL: ?theme=dark) */
    .theme-dark {
      --bg: #0b0d12;
      --panel: #121621;
      --text: #e8ecf1;
      --muted: #9aa7b2;
      --hash: rgba(231, 234, 239, 0.16);
      --grid: #2a3242;
      --grid-strong: #3a4458;
      --accent: #5bbcff;
      --head: #0f1522;
      --maybe-bg: rgba(160,170,180,0.7);
      --today-border: #f2b200;
      --today-bg: #3a2a00;
    }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 24px; background: var(--bg); color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .container { display: inline-block; margin: 0 auto; padding: 24px; }
    h1 { font-size: 20px; font-weight: 600; margin: 0 0 16px; letter-spacing: 0.2px; display: flex; align-items: center; gap: 10px; }
    /* Right-aligned yellow group badge shown next to the first title */
    .group-badge {
      margin-left: auto;
      background: #ffd666; /* warm yellow */
      color: #000; /* black text as requested */
      border-radius: 17px;
      padding: 0 15px;
      height: 35px;
      line-height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 400;
      border: 1px solid #e3b617; /* subtle outline for contrast on both themes */
      box-shadow: 0 0 0 1px rgba(0,0,0,0.02) inset;
    }
    .panel { background: var(--panel); width: 835px; }
    .table-wrap { overflow: auto; margin-bottom: 24px; border-radius: 10px; }
    table { border-collapse: separate; border-spacing: 0; width: max-content; min-width: 100%; }
    th, td { border-right: 1px solid var(--grid); border-bottom: 1px solid var(--grid); padding: 0; text-align: center; white-space: nowrap; font-size: 12px; }
    th { background: var(--head); color: var(--text); position: sticky; top: 0; z-index: 2; }
    thead th:first-child { left: 0; z-index: 3; position: sticky; text-align: left; white-space: normal; }
    tbody th { position: sticky; left: 0; z-index: 1; background: linear-gradient(90deg, var(--head), var(--panel)); text-align: left; padding: 0 10px }
    thead th, tbody th { font-weight: 600; }
    thead th:first-child, tbody th { border-left: 1px solid var(--grid-strong); }
    thead th:last-child, tbody td:last-child { border-right: 1px solid var(--grid-strong); }
    tbody tr:last-child td, tbody tr:last-child th { border-bottom: 1px solid var(--grid-strong); }
    thead tr:first-child th { border-top: 1px solid var(--grid-strong); }
    thead th:first-child { border-top-left-radius: 10px; padding: 0 10px; }
    thead th:last-child { border-top-right-radius: 10px; }
    tbody tr:last-child th { border-bottom-left-radius: 10px; }
    tbody tr:last-child td:last-child { border-bottom-right-radius: 10px; }
    .muted { color: var(--muted); font-weight: 100; font-size: 10px; }
    .hash { color: var(--hash); font-weight: 100; font-size: 10px; }

    /* Rotate header time labels (first row, starting from the second cell) */
    thead th:not(:first-child) > .vlabel {
      writing-mode: vertical-rl;      /* vertical text */
      text-orientation: mixed;        /* keep digits readable */
      letter-spacing: 0.3px;
      padding: 10px 6px;              /* a bit narrower since vertical */
      display: inline-block;
      vertical-align: bottom;         /* align baseline nicely */
    }

    /* Matrix sizing rules */
    *, *::before, *::after { box-sizing: border-box; }
    tbody td {
      width: 30px;
      height: 38px;
      padding: 0;
    }
    thead th {
      height: 55px;
      min-width: 30px;
    }
    tbody th {
      height: 38px;
      max-width: 105px;
      min-width: 70px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Cell state coloring */
    tbody td.state-yes { background: white; }
    tbody td.state-no { background: var(--maybe-bg); }
    tbody td.state-maybe { background: var(--maybe-bg); }
    tbody td.state-mfirst, tbody td.state-first { background: linear-gradient(90deg, var(--maybe-bg) 0 50%, white 50% 100%); }
    tbody td.state-msecond, tbody td.state-second { background: linear-gradient(90deg, white 0 50%, var(--maybe-bg) 50% 100%); }

    /* Center icons inside cells and fix their size */
    tbody td { text-align: center; }
    tbody td .cell-icon { width: 20px; height: 20px; display: inline-block; margin-top: 3px; }

    /* Weekly matrix: highlight today's row */
    #matrix tbody tr.is-today { border-top-color: var(--today-border) !important;}
    #matrix tbody tr.is-today th,
    #matrix tbody tr.is-today td { border-top-color: var(--today-border) !important; border-bottom-color: var(--today-border) !important; }
    #matrix tbody tr.is-today > th { background: var(--today-bg) !important; }

    /* Legend */
    .legend { display: flex; flex-wrap: wrap; gap: 10px 24px; align-items: center; margin: 12px 0 0; }
    .legend-item { display: inline-flex; align-items: center; font-size: 10px; }
    .legend-box { width: 30px; height: 38px; border: 1px solid var(--grid); box-sizing: border-box; margin-right: 8px; display: flex; align-items: center; justify-content: center; }
    .legend-box .cell-icon { width: 20px; height: 20px; display: block; }
    /* Use same coloring as matrix states */
    .legend-box.state-yes { background: white; }
    .legend-box.state-no { background: var(--maybe-bg); }
    .legend-box.state-maybe { background: var(--maybe-bg); }
    .legend-box.state-mfirst { background: linear-gradient(90deg, var(--maybe-bg) 0 50%, white 50% 100%); }
    .legend-box.state-msecond { background: linear-gradient(90deg, white 0 50%, var(--maybe-bg) 50% 100%); }
  </style>
</head>
<body>
  <div class="container">
    <h1>Графік відключень:</h1>
    <p class="muted" id="lastUpdated"></p>
    <div class="panel table-wrap">
      <table id="today"></table>
    </div>
    <h1>Графік можливих відключень на тиждень:</h1>
    <div class="panel table-wrap">
      <table id="matrix"></table>
    </div>
    <div class="legend" aria-label="Легенда">
      <div class="legend-item"><span class="legend-box state-yes" title="Світло є"></span> Світло є</div>
      <div class="legend-item"><span class="legend-box state-no" title="Світла нема"><img class="cell-icon" src="icons/no.svg" width="20" height="20" alt="" aria-hidden="true"></span> Світла нема</div>
      <div class="legend-item"><span class="legend-box state-maybe" title="Можливо відключення"><img class="cell-icon" src="icons/maybe.svg" width="20" height="20" alt="" aria-hidden="true"></span> Можливо відключення</div>
      <div class="legend-item"><span class="legend-box state-mfirst" title="Світла можливо не буде перші 30 хв"><img class="cell-icon" src="icons/mfirst.svg" width="20" height="20" alt="" aria-hidden="true"></span> Перші 30 хв.</div>
      <div class="legend-item"><span class="legend-box state-msecond" title="Світла можливо не буде другі 30 хв"><img class="cell-icon" src="icons/msecond.svg" width="20" height="20" alt="" aria-hidden="true"></span> Другі 30 хв.</div>
    </div>
    <p class="muted hash" id="meta"></p>
  </div>
  <script>
    (function(){
      try {
        const qs = new URLSearchParams(location.search);
        if (qs.get('theme') === 'dark') document.body.classList.add('theme-dark');
      } catch (e) {}
    })();

    function pickGpvKey(data) {
      try {
        const qs = new URLSearchParams(location.search);
        const fromUrl = qs.get('gpv');
        if (fromUrl && data?.preset?.data && data.preset.data[fromUrl]) return fromUrl;
      } catch (e) {}
      if (window.__GPV_KEY__ && data?.preset?.data && data.preset.data[window.__GPV_KEY__]) return window.__GPV_KEY__;
      const keys = Object.keys(data?.preset?.data || {});
      const firstGpv = keys.find(k => /^GPV\d+\.\d+$/.test(k));
      return firstGpv || 'GPV1.2';
    }

    // Map cell state to icon file path (relative to scripts/full-template.html)
    function stateIconSrc(state) {
      switch (state) {
        case 'no': return 'icons/no.svg';
        case 'maybe': return 'icons/maybe.svg';
        case 'mfirst':
        case 'first': return 'icons/mfirst.svg';
        case 'msecond':
        case 'second': return 'icons/msecond.svg';
        default: return null;
      }
    }

    async function load() {
      let data = null;
      if (window.__SCHEDULE__) {
        data = window.__SCHEDULE__;
      } else {
        // Fallback: try to fetch by region param or default kyiv-region
        let regionId = 'kyiv-region';
        try {
          const qs = new URLSearchParams(location.search);
          regionId = qs.get('region') || regionId;
        } catch (e) {}
        const url = `../data/${regionId}.json`;
        try {
          const res = await fetch(url);
          data = await res.json();
        } catch (e) {
          document.getElementById('meta').textContent = 'Не вдалося завантажити дані (' + url + '). Запустіть локальний сервер (наприклад: npx serve або python3 -m http.server) з кореня проєкту.';
          return;
        }
      }

      // Show last updated above the title (prefer top-level ISO lastUpdated; fallback to fact.update)
      try {
        let updatedLabel = '';
        if (data.lastUpdated) {
          try {
            const d = new Date(data.lastUpdated);
            const parts = new Intl.DateTimeFormat('uk-UA', {
              timeZone: 'Europe/Kyiv', year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false
            }).formatToParts(d);
            const get = t => parts.find(p => p.type === t)?.value || '';
            const dd = get('day');
            const mm = get('month');
            const yyyy = get('year');
            const hh = get('hour');
            const min = get('minute');
            updatedLabel = `${dd}.${mm}.${yyyy} ${hh}:${min}`;
          } catch (_) {}
        }
        if (!updatedLabel && data.fact && data.fact.update) {
          updatedLabel = data.fact.update;
        }
        if (updatedLabel) {
          document.getElementById('lastUpdated').textContent = 'Дата та час останнього оновлення інформації на графіку: ' + updatedLabel;
        }
      } catch (_) {}

      const gpvKey = pickGpvKey(data);

      // Inject group badge next to the first title (right-aligned)
      try {
        const h1 = document.querySelector('.container > h1');
        if (h1) {
          const names = data?.preset?.sch_names || {};
          let label = names[gpvKey] || '';
          if (label) {
            // Convert "Черга 1.2" -> "Черга: 1.2"
            label = label.replace(/^Черга\b\s*/, 'Черга: ');
          } else if (gpvKey) {
            const m = String(gpvKey).match(/^GPV(\d+)\.(\d+)$/);
            if (m) label = `Черга: ${m[1]}.${m[2]}`;
          }
          if (label) {
            let badge = h1.querySelector('.group-badge');
            if (!badge) {
              badge = document.createElement('span');
              badge.className = 'group-badge';
              h1.appendChild(badge);
            }
            badge.textContent = label;
          }
        }
      } catch (_) {}

      // Build top 25x2 table for today (from fact)
      buildToday(data.preset, data.fact, gpvKey);

      // Compute today's weekday index (1=Mon..7=Sun) in Europe/Kyiv from fact.today
      let todayIdx = null;
      try {
        const epoch = data?.fact?.today;
        if (epoch != null) {
          const baseDate = new Date(Number(epoch) * 1000);
          const w = new Intl.DateTimeFormat('en-GB', { timeZone: 'Europe/Kyiv', weekday: 'short' }).format(baseDate);
          const map = { Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6, Sun: 7 };
          todayIdx = map[w] || null;
        }
      } catch (_) {}

      // Build weekly table and highlight today's row
      build(data.preset, gpvKey, todayIdx);

      // Show meta: prefer contentHash under the map, fallback to update
      const hash = data.meta && data.meta.contentHash;
      if (hash) {
        document.getElementById('meta').textContent = 'contentHash: ' + hash;
      } else if (data.fact && data.fact.update) {
        document.getElementById('meta').textContent = 'Оновлено: ' + data.fact.update;
      }
    }

    function build(preset, gpvKey, todayWeekdayIdx) {
      const table = document.getElementById('matrix');
      table.innerHTML = '';

      // Collect ordered time slots (1..24)
      const tzKeys = Object.keys(preset.time_zone).map(Number).sort((a,b)=>a-b);
      const times = tzKeys.map(k => preset.time_zone[String(k)][0]); // label like "00-01"

      // Collect ordered days (1..7)
      const dayKeys = Object.keys(preset.days).map(Number).sort((a,b)=>a-b);
      const days = dayKeys.map(k => preset.days[String(k)]);

      // THEAD
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');

      const corner = document.createElement('th');
      corner.innerHTML = 'Часові<br>проміжки';
      hr.appendChild(corner);

      for (const t of times) {
        const th = document.createElement('th');
        const div = document.createElement('div');
        div.className = 'vlabel';
        div.textContent = t;
        th.appendChild(div);
        hr.appendChild(th);
      }
      thead.appendChild(hr);

      // TBODY
      const tbody = document.createElement('tbody');
      const schedule = preset.data && preset.data[gpvKey];

      if (!schedule) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = 'Помилка: відсутні дані для ' + gpvKey;
        th.colSpan = 1 + tzKeys.length;
        tr.appendChild(th);
        tbody.appendChild(tr);
        table.appendChild(thead);
        table.appendChild(tbody);
        return;
      }

      dayKeys.forEach(dk => {
        const dayName = preset.days[String(dk)];
        const tr = document.createElement('tr');
        if (todayWeekdayIdx && Number(dk) === Number(todayWeekdayIdx)) {
          tr.classList.add('is-today');
        }
        const th = document.createElement('th');
        th.textContent = dayName; tr.appendChild(th);

        tzKeys.forEach(hk => {
          const td = document.createElement('td');
          const value = schedule?.[String(dk)]?.[String(hk)];
          if (value) {
            td.classList.add('state-' + value);
            const timeLabel = preset.time_zone[String(hk)]?.[0] || '';
            const desc = preset.time_type?.[value] || value;
            td.title = dayName + ' ' + timeLabel + ' — ' + desc;
            const iconSrc = stateIconSrc(value);
            if (iconSrc) {
              const img = document.createElement('img');
              img.className = 'cell-icon';
              img.src = iconSrc;
              img.width = 20;
              img.height = 20;
              img.alt = '';
              img.setAttribute('aria-hidden', 'true');
              img.decoding = 'async';
              td.appendChild(img);
            }
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });

      table.appendChild(thead);
      table.appendChild(tbody);
    }

    function buildToday(preset, fact, gpvKey) {
      const table = document.getElementById('today');
      if (!table) return;
      table.innerHTML = '';

      // Ordered time slots
      const tzKeys = Object.keys(preset.time_zone).map(Number).sort((a,b)=>a-b);

      // THEAD
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');
      const corner = document.createElement('th');
      corner.innerHTML = 'Часові<br>проміжки';
      hr.appendChild(corner);
      for (const hk of tzKeys) {
        const th = document.createElement('th');
        const div = document.createElement('div');
        div.className = 'vlabel';
        div.textContent = preset.time_zone[String(hk)]?.[0] || '';
        th.appendChild(div);
        hr.appendChild(th);
      }
      thead.appendChild(hr);

      // Helper to render a single row by day epoch key
      function renderRow(label, dayEpoch) {
        const tr = document.createElement('tr');
        const rowTh = document.createElement('th');
        rowTh.textContent = label;
        tr.appendChild(rowTh);

        const dayObj = fact && fact.data && (dayEpoch != null) && fact.data[String(dayEpoch)];
        const schedule = dayObj && (dayObj[gpvKey]);

        tzKeys.forEach(hk => {
          const td = document.createElement('td');
          const raw = schedule?.[String(hk)];
          if (raw) td.classList.add('state-' + raw);
          const timeLabel = preset.time_zone[String(hk)]?.[0] || '';
          const desc = raw ? (preset.time_type?.[raw] || raw) : '';
          if (desc) td.title = label + ' ' + timeLabel + ' — ' + desc;
          const iconSrc = raw ? stateIconSrc(raw) : null;
          if (iconSrc) {
            const img = document.createElement('img');
            img.className = 'cell-icon';
            img.src = iconSrc;
            img.width = 20;
            img.height = 20;
            img.alt = '';
            img.setAttribute('aria-hidden', 'true');
            img.decoding = 'async';
            td.appendChild(img);
          }
          tr.appendChild(td);
        });
        return tr;
      }

      // TBODY (rows for today and tomorrow)
      const tbody = document.createElement('tbody');

      const todayEpoch = (fact && fact.today != null) ? Number(fact.today) : null;
      if (todayEpoch != null) {
        tbody.appendChild(renderRow('Сьогодні', todayEpoch));
      }

      // Pick another key from fact.data that does NOT equal fact.today (prefer the next chronological as "tomorrow")
      let tomorrowEpoch = null;
      try {
        const keys = Object.keys(fact?.data || {}).map(Number).filter(n => !Number.isNaN(n));
        if (keys.length) {
          const greater = keys.filter(k => todayEpoch != null ? k > todayEpoch : true).sort((a,b)=>a-b);
          tomorrowEpoch = greater[0] ?? keys.find(k => k !== todayEpoch) ?? null;
        }
      } catch (_) {}

      if (tomorrowEpoch != null && tomorrowEpoch !== todayEpoch) {
        let label = 'Завтра';
        try {
          const d = new Date(Number(tomorrowEpoch) * 1000);
          const parts = new Intl.DateTimeFormat('uk-UA', { timeZone: 'Europe/Kyiv', day: '2-digit', month: '2-digit' }).formatToParts(d);
          const get = t => parts.find(p => p.type === t)?.value || '';
          const dd = get('day');
          const mm = get('month');
          if (dd && mm) label = `Завтра (${dd}.${mm})`;
        } catch (_) {}
        tbody.appendChild(renderRow(label, tomorrowEpoch));
      }

      table.appendChild(thead);
      table.appendChild(tbody);
    }

    load();
  </script>
</body>
</html>
