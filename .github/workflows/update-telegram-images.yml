name: Update Telegram images (hourly)

on:
  schedule:
    - cron: '0 * * * *'   # кожну годину (UTC)
  workflow_dispatch:      # ручний запуск

jobs:
  update-images:
    runs-on: ubuntu-latest
    env:
      BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
      CHATS_JSON: ${{ vars.CHATS_JSON }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Run Telegram update script
        run: |
          cat > update-telegram.js <<'EOF'
          const token = process.env.BOT_TOKEN;
          const raw = process.env.CHATS_JSON;

          if (!token) {
            console.error('ERROR: BOT_TOKEN не заданий (збережи як GitHub Secret).');
            process.exit(2);
          }
          if (!raw) {
            console.error('ERROR: CHATS_JSON не заданий (збережи як Actions Variable).');
            process.exit(3);
          }

          let chats;
          try {
            chats = JSON.parse(raw);
          } catch (err) {
            console.error('ERROR: Не вдалося розпарсити CHATS_JSON:', err.message);
            process.exit(4);
          }

          if (!Array.isArray(chats) || chats.length === 0) {
            console.error('ERROR: CHATS_JSON має бути масивом з конфігурацією чатів.');
            process.exit(5);
          }

          const API_BASE = `https://api.telegram.org/bot${token}`;

          function getTimestamp() {
            const now = new Date();
            const pad = (n) => n.toString().padStart(2, '0');
            return `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}`;
          }

          function withTimestamp(caption) {
            const ts = getTimestamp();
            return caption ? `${caption}\nОновлено: ${ts}` : `Оновлено: ${ts}`;
          }

          function cacheBustedUrl(url) {
            try {
              const u = new URL(url);
              u.searchParams.set('cb', Date.now().toString());
              return u.toString();
            } catch {
              const sep = url.includes('?') ? '&' : '?';
              return `${url}${sep}cb=${Date.now()}`;
            }
          }

          async function sendPhoto(chat) {
            const url = `${API_BASE}/sendPhoto`;
            const caption = withTimestamp(chat.caption);
            const photoUrl = cacheBustedUrl(chat.image_url);
            const body = { chat_id: chat.chat_id, photo: photoUrl, caption };
            try {
              const res = await fetch(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
              const json = await res.json();
              if (!json.ok) { console.error(`sendPhoto ERROR for ${chat.chat_id}:`, JSON.stringify(json)); return { ok: false, chat, json }; }
              const messageId = json.result.message_id;
              console.log(`SENT new message for chat_id=${chat.chat_id} -> message_id=${messageId}`);
              await pinMessage(chat.chat_id, messageId);
              return { ok: true, chat, message_id: messageId, result: json.result };
            } catch (err) {
              console.error(`Network error sendPhoto for ${chat.chat_id}:`, err.message);
              return { ok: false, chat, err };
            }
          }

          async function editPhoto(chat) {
            const url = `${API_BASE}/editMessageMedia`;
            const caption = withTimestamp(chat.caption);
            const photoUrl = cacheBustedUrl(chat.image_url);
            const payload = { chat_id: chat.chat_id, message_id: Number(chat.message_id), media: { type:"photo", media: photoUrl, caption } };
            try {
              const res = await fetch(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
              const json = await res.json();
              if (!json.ok) {
                if (json.error_code===400 && json.description.includes('message is not modified')) {
                  console.log(`NOT_MODIFIED for ${chat.chat_id}/${chat.message_id}, considered OK.`);
                  await pinMessage(chat.chat_id, chat.message_id);
                  return { ok: true, chat, not_modified: true };
                }
                console.error(`editMessageMedia ERROR for ${chat.chat_id}/${chat.message_id}:`, JSON.stringify(json));
                return { ok: false, chat, json };
              }
              console.log(`EDITED chat_id=${chat.chat_id} message_id=${chat.message_id} OK`);
              await pinMessage(chat.chat_id, chat.message_id);
              return { ok: true, chat, result: json.result };
            } catch (err) {
              console.error(`Network error editMessageMedia for ${chat.chat_id}/${chat.message_id}:`, err.message);
              return { ok: false, chat, err };
            }
          }

          async function pinMessage(chat_id, message_id) {
            const url = `${API_BASE}/pinChatMessage`;
            try {
              const res = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ chat_id, message_id, disable_notification:true }) });
              const json = await res.json();
              if (!json.ok) { console.error(`pinChatMessage ERROR for ${chat_id}/${message_id}:`, JSON.stringify(json)); return { ok: false }; }
              console.log(`PINNED chat_id=${chat_id} message_id=${message_id} OK`);
              return { ok: true };
            } catch (err) {
              console.error(`Network error pinChatMessage for ${chat_id}/${message_id}:`, err.message);
              return { ok: false };
            }
          }

          (async () => {
            const results = [];
            for (const c of chats) {
              if (!c.chat_id || !c.image_url) { console.error('SKIP invalid-config:', JSON.stringify(c)); results.push({ ok:false, chat:c, reason:'invalid-config'}); continue; }
              if (!c.message_id) { results.push(await sendPhoto(c)); } 
              else { results.push(await editPhoto(c)); }
              await new Promise(r => setTimeout(r, 600));
            }
            const failures = results.filter(r => !r.ok && r.reason!=='invalid-config');
            if (failures.length) { console.error(`Completed with ${failures.length} failures out of ${results.length}.`); process.exit(10); }
            console.log('All chats processed (success / not-modified / skipped invalid-config).');
          })();
          EOF

          node update-telegram.js
